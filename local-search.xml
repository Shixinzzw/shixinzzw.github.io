<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>三相PFC电路结构及控制器设计</title>
    <link href="/2023/06/13/%E4%B8%89%E7%9B%B8PFC%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%84%E5%8F%8A%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/06/13/%E4%B8%89%E7%9B%B8PFC%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%84%E5%8F%8A%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LVGL 移植与界面开发</title>
    <link href="/2023/06/13/LVGL-%E7%A7%BB%E6%A4%8D%E4%B8%8E%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    <url>/2023/06/13/LVGL-%E7%A7%BB%E6%A4%8D%E4%B8%8E%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GTK4 程序开发</title>
    <link href="/2023/06/13/GTK4-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2023/06/13/GTK4-%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单相图腾柱PFC的SOGI控制</title>
    <link href="/2023/06/13/%E5%8D%95%E7%9B%B8%E5%9B%BE%E8%85%BE%E6%9F%B1PFC%E7%9A%84SOGI%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/06/13/%E5%8D%95%E7%9B%B8%E5%9B%BE%E8%85%BE%E6%9F%B1PFC%E7%9A%84SOGI%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">0 摘要</h2><p>本文主要介绍了图腾柱拓扑结构的PFC电路结构，及其基于SOGI算法的控制器设计。包括原理讲解、算法介绍、Matlab仿真、实际PCB版图绘制几个内容。</p><!---more---><h2 id="图腾柱电路拓扑结构介绍">1 图腾柱电路拓扑结构介绍</h2>]]></content>
    
    
    <categories>
      
      <category>Control</category>
      
      <category>Power Electronic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PFC</tag>
      
      <tag>SOGI Control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单相Boost型PFC原理及控制</title>
    <link href="/2023/06/13/%E5%8D%95%E7%9B%B8Boost%E5%9E%8BPFC%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/06/13/%E5%8D%95%E7%9B%B8Boost%E5%9E%8BPFC%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">0 摘要</h2><p>本文主要记录在设计高频整流电路中，采用Boost开关电路进行功率因素矫正的问题，也是PFC系列的第一篇介绍文章。从功率因素、Boost电路结构、PFC控制算法、Matlab仿真、功率电路设计、嵌入式代码编写五个部分进行介绍，同时记录下在设计过程中面临的一些问题。</p><!---more---><h2 id="功率因素">1 功率因素</h2><p>对于正弦电路系统，电压和电流的相位关系是必须考虑的问题。正是由于电容电阻这类储能元件的作用，会存在使电压与电流的相位存在超前和滞后的关系，电路系统不单单存在能量的消耗，还会有能量的相互转换。</p><p>在考虑交流系统的能量关系时，有如下几个概念需要了解：瞬时功率、有功功率，无功功率和视在功率。同时引出关于功率因素的概念。</p><p>设输入某网络的交流电：</p><p><span class="math display">\[u = \sqrt{2} \times U sin \space (\omega t + \phi_u) \\i = \sqrt{2} \times I sin \space (\omega t + \phi_i)\]</span></p><p>其中<span class="math inline">\(u\)</span>为瞬时电压、<spanclass="math inline">\(U\)</span> 为电压有效值、 <spanclass="math inline">\(\omega\)</span> 为交流电频率、<spanclass="math inline">\(\phi_u\)</span> 为电压相位；<spanclass="math inline">\(i\)</span>为瞬时电流、<spanclass="math inline">\(U\)</span> 为电流有效值、 <spanclass="math inline">\(\omega\)</span> 为交流电频率、<spanclass="math inline">\(\phi_u\)</span> 为电压相位。</p><h2 id="基于boost电路的pfc控制设计">2 基于Boost电路的PFC控制设计</h2><h3 id="功率级主电路结构">2.1 功率级主电路结构</h3><h3 id="pfc控制算法设计">2.2 PFC控制算法设计</h3><h2 id="matlab仿真">3 Matlab仿真</h2><h2 id="主电路的pcb设计">4 主电路的PCB设计</h2><h2 id="控制程序代码编写">5 控制程序代码编写</h2><h2 id="一些测试数据">6 一些测试数据</h2><h2 id="参考文章">7 参考文章</h2>]]></content>
    
    
    <categories>
      
      <category>Control</category>
      
      <category>Power Electronic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Boost</tag>
      
      <tag>PFC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三相逆变器与无感FOC控制</title>
    <link href="/2023/06/13/%E4%B8%89%E7%9B%B8%E9%80%86%E5%8F%98%E5%99%A8%E4%B8%8E%E6%97%A0%E6%84%9FFOC%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/06/13/%E4%B8%89%E7%9B%B8%E9%80%86%E5%8F%98%E5%99%A8%E4%B8%8E%E6%97%A0%E6%84%9FFOC%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于开关电源的软起动问题</title>
    <link href="/2023/06/13/%E5%85%B3%E4%BA%8E%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%E7%9A%84%E8%BD%AF%E8%B5%B7%E5%8A%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2023/06/13/%E5%85%B3%E4%BA%8E%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%E7%9A%84%E8%BD%AF%E8%B5%B7%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Ubuntu Server 20.04配置树莓派3B ROS1 系统环境总结</title>
    <link href="/2023/04/22/%E4%BD%BF%E7%94%A8Ubuntu-Server-20-04%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE3B-ROS1-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/22/%E4%BD%BF%E7%94%A8Ubuntu-Server-20-04%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE3B-ROS1-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>本文主要总结使用树莓派官方镜像工具配置基于UbuntuServer环境下ROS1的一些坑，想到什么就写什么了。 <span id="more"></span></p><h2 id="boot分区切记记得备份"><code>\Boot</code>分区切记记得备份</h2><p>本人在配置环境时，由于实验室的网络情况对外网的访问不佳，因此要反复切换WIFI连接。而切换WiFi时需要将树莓派的SD卡取下，插入电脑编辑<code>\Boot</code>分区下的<code>network-config</code>文件来改变每次开机所连接的热点，一次拔插过程中（无论是树莓派下拔插，还是电脑拔插）都有可能将SD卡的文件系统损坏。具体描述似乎时不正确的拔插U盘或者SD卡，可能导致文件系统中的数据发生漂移，导致数据和扇区不对应。因此最好是系统镜像写入后使用diskgines之类的软件将你的<code>\Boot</code>分区进行备份。</p><h2 id="ubuntuserver下wifi配置的问题">UbuntuServer下WiFi配置的问题</h2><p>在<code>\Boot</code>区编辑<code>network-config</code>文件时，极有可能还是无法连接到热点，这是由于Ubuntu系统下的<code>/etc/netplan/50-cloud-init.yaml</code>没有更新，因此还需要修改这个文件然后重启系统再来连接网络。</p><h2 id="swap分区创建"><code>swap</code>分区创建</h2><p>树莓派的运行内存大多比较小，如果我们后续还需要配置桌面环境，编译一些项目的话，会显得十分的捉襟见肘，因此十分有必要去创建以一个比较大的swap分区以供后续使用。流程如下：</p><figure><img src="/image/raspberryPI/mkswap.png" alt="创建swap分区流程" /><figcaption aria-hidden="true">创建swap分区流程</figcaption></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Shixin的技术栈</title>
    <link href="/2023/04/05/Shixin%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <url>/2023/04/05/Shixin%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>本文主要总结了一下我个人觉得需要掌握的一些技术能力。 <span id="more"></span> ##Shixin的技术栈</p><p>Linux嵌入式+边缘（神经网络，计算机视觉）计算［有前景］STM32嵌入式开发 （STM32CubeMX，HAL库） 国产嵌入式芯片开发C语言，C++，CMake，JSON，Lua Git项目管理 自动控制原理，现代控制原理算法各类学习 MATLAB/SIMULINK 电力电子技术，PFC，逆变器...及其仿真PPL，SOGI，等电源控制技术 Linux系统，ROS机器人系统 机器学习，PythonOpenCV，C++计算机视觉 GTK，QT界面开发 PCB电路板设计（KiCAD）基础的机械设计（FreeCAD）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云loT开发（ESP32）</title>
    <link href="/2023/02/26/%E8%85%BE%E8%AE%AF%E4%BA%91loT%E5%BC%80%E5%8F%91%EF%BC%88ESP32%EF%BC%89/"/>
    <url>/2023/02/26/%E8%85%BE%E8%AE%AF%E4%BA%91loT%E5%BC%80%E5%8F%91%EF%BC%88ESP32%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些有用的东西</title>
    <link href="/2023/02/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <url>/2023/02/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="记录一些有用的贴子">记录一些有用的贴子</h2><span id="more"></span><p>独石电容、瓷片电容、陶瓷电容什么关系？https://www.ednchina.com/news/202003061531.html</p><p>用Visual Studio 2019 开发stm32，cortex-m3, armhttps://blog.csdn.net/u013866683/article/details/103242378</p><p>STM32单片机的核心板设计与总结https://www.jianshu.com/p/c90190e93307</p><p>第七章 STM32核心板PCB设计（布局布线+注意的疑难问题）https://blog.csdn.net/weixin_44917390/article/details/119063237</p><p>STM32f407程序移植到GD32F407https://blog.csdn.net/freemote/article/details/119815607</p><p>电源符号：VCC、VDD、VEE、VSS、VBAT各表示什么意思？https://blog.csdn.net/weibo1230123/article/details/80372998</p><p>常用元器件的原理图符号和元器件封装汇总https://zhuanlan.zhihu.com/p/337450458</p><p>硬件工程师入门基础知识（一）基础元器件认识（一）https://blog.csdn.net/qq_41600018/article/details/128993041</p><p>C语言中，全局变量滥用的后果竟如此严重？https://blog.csdn.net/best_xiaolong/article/details/106485002</p><p>配置CLion用于STM32开发【优雅の嵌入式开发】https://zhuanlan.zhihu.com/p/145801160注：需要将openocd目录下的openocd/openocd中的内容移出</p><p>STM32应用之TFT1.44寸屏ST7735驱动 SPI通信https://blog.csdn.net/qq_26106317/article/details/105853107</p><p>关于STM32CubeMX时钟设置中CSS Enable的作用</p><p>Latex 联立方程：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;cases&#125;<br>       1.392f<span class="hljs-built_in">_</span>0=6.436<span class="hljs-keyword">\psi</span><span class="hljs-built_in">_</span>1-2.718 <span class="hljs-keyword">\\</span><br>        -4.718<span class="hljs-keyword">\psi</span><span class="hljs-built_in">_</span>1+6.436=-f<span class="hljs-built_in">_</span>0 <span class="hljs-keyword">\\</span> <br>        -2.718<span class="hljs-keyword">\psi</span><span class="hljs-built_in">_</span>1=0 <span class="hljs-keyword">\\</span><br>       <span class="hljs-keyword">\psi</span><span class="hljs-built_in">_</span>1-4.718=0<br> <span class="hljs-keyword">\end</span>&#123;cases&#125;<br></code></pre></td></tr></table></figure><p><span class="math display">\[\begin{cases}       1.392f_0=6.436\psi_1-2.718 \\        -4.718\psi_1+6.436=-f_0 \\        -2.718\psi_1=0 \\       \psi_1-4.718=0\end{cases}\]</span></p><p>Rplidar A1从测试到使用-在ROS中使用和用来建图https://blog.csdn.net/zhangkkit/article/details/109569240</p><p>ubuntu22+xfce4+tigervnc配置https://www.cnblogs.com/xaoyxc/p/17041180.html</p><p>ROS学习--第3篇：ROS基础---创建工作空间https://blog.csdn.net/weixin_42237429/article/details/90238000</p><p>Ubuntu 20.04 设置 DNS 的方法https://www.cnblogs.com/mouseleo/p/14976527.html</p><p>Ubuntu查看并修改DNShttps://blog.csdn.net/qq_26230847/article/details/119962894</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>夏季柠檬饮料摆摊销售价值分析</title>
    <link href="/2023/01/07/%E5%A4%8F%E5%AD%A3%E6%9F%A0%E6%AA%AC%E9%A5%AE%E6%96%99%E6%91%86%E6%91%8A%E9%94%80%E5%94%AE%E4%BB%B7%E5%80%BC%E5%88%86%E6%9E%90/"/>
    <url>/2023/01/07/%E5%A4%8F%E5%AD%A3%E6%9F%A0%E6%AA%AC%E9%A5%AE%E6%96%99%E6%91%86%E6%91%8A%E9%94%80%E5%94%AE%E4%BB%B7%E5%80%BC%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="夏季柠檬饮料摆摊销售价值分析">夏季柠檬饮料摆摊销售价值分析</h2><p>虽然是在冬季，但是近期本人购买了ARTEASG的柠檬红茶产品，该产品售卖价格为10 元每杯，其产品如下图: <img src="/image/ningmengshui/产品示意图01.jpg"alt="产品示意图" /></p><p>拿到手后，又觉得这东西成本应该很低，10元的售价应该有很大的利润空间，于是就想如果夏季摆摊卖柠檬饮料，应该也能赚点小钱，补贴一下生活费。下面对这个产品的销售和盈利情况进行分析。<span id="more"></span> ### 1. 项目背景</p><p>柠檬饮料是一种常见的饮料，其酸甜的口感和清爽的味道，使得它在夏季的销售量大大增加。分析其销售价值可以展望其利润空间及其销售策略。</p><p>夏季炎热，但是夏季夜晚的街道上的人流量却不少，这是因为夏季的夜晚比较凉爽，人们可以在夜晚散步，享受夜晚的清爽。夏季的夜晚，人们的消费意愿也会增加。因此，夏季的夜晚是柠檬饮料销售的好时机。</p><figure><img src="/image/ningmengshui/夜市.jpg" alt="夜市场景" /><figcaption aria-hidden="true">夜市场景</figcaption></figure><p>想象一下这个场景，夏季的夜晚，人们在街道上散步，夏日的晚风吹拂，街道人来人往，突然看到一家柠檬饮料摊点，各色的柠檬饮料，冰爽可口，沁人心脾，总会想去购买一杯，享受一下夏日的清爽。</p><h3 id="项目分析">2. 项目分析</h3><h4 id="产品分析">2.1 产品分析</h4><p>以我所购买的 500mL柠檬红茶为例，其主要原料为柠檬、红茶、冰块、糖浆、水、出品杯。一杯柠檬红茶，如果柠檬味要想馥郁，则需要购买香水柠檬，其每杯柠檬克重应不少于100g，大致相当于1颗柠檬。现在讨论红茶，红茶一般需要在出摊前一次泡好，且茶汤需要较高的浓度才能使其味道不会被柠檬所掩盖，暂定每杯茶汤为300mL 。一杯柠檬红茶，糖浆必不可少，500mL 的的容量，大概可以给10 - 20g左右的糖浆。剩下的 100mL来自冰块，由于摆摊售卖需要制备大量冰块，因此可以采用制冰机或者冰格冻制两种，制冰机的制冰效率较高，但是制冰机的制冰成本较高，冰格冻制的制冰效率较低，但是制冰成本较低，因此需要根据总体的销售量来确定制冰方法。水的来源可以是自来水，也可以是矿泉水，但是产品质量需要保证则最好使用瓶装水，可以选择怡宝，农夫山泉。出品杯则可以在拼多多等平台上购买。</p><p>500mL 柠檬红茶单杯原料表 |原料|数目|备注| |:---:|:---:|:---:||柠檬|100-150 g|最好选用香水柠檬| |茶汤|300-350mL|可以多种选择，绿茶，红茶| |糖浆|10-20 g|| |冰块|100 g|单格10ml 10块||水|100 mL|怡宝，农夫山泉大容量| |出品杯|1 个|拼多多等平台购买|</p><h4 id="产品销售成本分析">2.2 产品销售成本分析</h4><p>下面以出售100杯为例，计算出售100杯500mL柠檬红茶的成本。根据上面讨论的单杯原料表，可以得出售卖100杯需要的原料数目如下表所示。</p><p>100杯 500mL 柠檬红茶单杯原料表 |原料|数目|合计| |:---:|:---:|:---:||柠檬|100-150 g|20-30斤| |茶汤|300-350 mL|4斤| |糖浆|10-20 g|2-4斤||冰块|100 g|10 L| |水|400 mL| 40 L| |出品杯|1 个| 100 个|</p><ol type="1"><li>夏季香水柠檬价格：15 元/斤</li><li>茶叶价格：大红袍 25 元/斤，绿茶 20 元/斤</li><li>糖浆价格：12 元/斤</li><li>水: 30 元/ 12.8L</li><li>出品杯： 100 个 50 元</li><li>冰格冻制模具：5层350格 21元。需要1000块，模具两组。</li></ol><p>则可计算出售卖100杯需要的原料成本为： <span class="math display">\[15 \times 25 + 25 \times 4 + 12 \times 4 + 30 \times 3 + 50 = 663 元\]</span></p><p>下面计算前期购买保温箱，冰格模具等设备成本：摆摊需要，折叠桌，折叠椅，冰块保温箱，茶汤罐。列表如下摆摊设备清单 |原料|数目|价格| |:---:|:---:|:---:| |折叠长桌|1 个| 190 元| |折叠椅|6 个| | |冰块保温箱|1 个| 50 元/13 L| |茶汤罐|4 个| 50元/个 ||冰格模具|2 组| 42 元|</p><p>则可计算出售卖100杯需要的设备成本为： <span class="math display">\[190 + 50 + 50 \times 4 + 42 \times 2 =  432 元\]</span></p><h4 id="产品销售收入分析">2.3 产品销售收入分析</h4><p>根据2.2节的成本分析，可知100杯柠檬红茶的成本为 663元。则每杯柠檬红茶的售价为 663/100 = 6.63元。因此销售价格必须高于6.63，且还是在没有考虑分摊设备成本的情况下。由于10元包括及其以上的成本将会减少消费者的购买意愿，因此售价设置为8元/杯较为合理。与其他奶茶店的价格相差不大，但是和蜜雪冰城等奶茶店相比，价格仍然偏高。因此，可以考虑在某些时候进行团购优惠活动，以吸引更多的消费者。</p><p>对于销售数目的建模，考虑到前期的销售量较小，后期每日销售量会逐渐增加，趋于稳定，估计后期人流稳定为200人/天。因此，可以考虑将销售量建模为一个分段模型，如下：<span class="math display">\[Sale (date)=\left \{\begin{aligned}\ 200 \times log_{15}(x+1), date &lt; 15\\200, date \geq 15 \\\end{aligned}\right.\]</span></p><figure><img src="/image/ningmengshui/前十天销售.jpg" alt="前15天销售量" /><figcaption aria-hidden="true">前15天销售量</figcaption></figure><p>再考虑设备成本和前期因售卖情况不佳造成的亏算，综合计算，40天内的总利润为：<span class="math display">\[(8-6.63)\times \sum_{date = 0}^{40} Sale(date) - (432 + 50 + 50 \times 4+ 42 \times 2) = 9,187.05 元\]</span></p><p>最终可以得到，40天内的总利润为 9,187.05 元，平均每天利润为 229.68元。但是需要注意的是，这个利润是在没有考虑到其他因素的情况下计算的，因此需要在实际运营中考虑到其他因素，如天气，人流量等。</p><h3 id="总结">3. 总结</h3><p>综合上述内容，可以得到如下结论</p><ol type="1"><li>夏季暑期售卖柠檬茶等饮品利润尚可，但需要注意选择人流量密度较高，且柠檬饮料需求较高的地点。</li><li>前期可以不必准备太多的设备，而是根据销售模型来确定出品杯数，以减少前期的亏损。</li><li>产品的价格设置应该在其他奶茶店的价格范围内，且不能过高，以吸引消费者。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Money Making</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Marketing</tag>
      
      <tag>Survey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 注释规范（基于 Doxygen）</title>
    <link href="/2022/11/12/C-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%EF%BC%88%E5%9F%BA%E4%BA%8E-Doxygen%EF%BC%89/"/>
    <url>/2022/11/12/C-%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%EF%BC%88%E5%9F%BA%E4%BA%8E-Doxygen%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>C&#92;C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 输出比较（Output Compare）与 PWM 生成（PWM Generation）之比较</title>
    <link href="/2022/11/06/STM32-%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%EF%BC%88Output-Compare%EF%BC%89%E4%B8%8E-PWM-%E7%94%9F%E6%88%90%EF%BC%88PWM-Generation%EF%BC%89%E4%B9%8B%E6%AF%94%E8%BE%83/"/>
    <url>/2022/11/06/STM32-%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%EF%BC%88Output-Compare%EF%BC%89%E4%B8%8E-PWM-%E7%94%9F%E6%88%90%EF%BC%88PWM-Generation%EF%BC%89%E4%B9%8B%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>程序风格与规范</title>
    <link href="/2022/10/29/%E7%A8%8B%E5%BA%8F%E9%A3%8E%E6%A0%BC%E4%B8%8E%E8%A7%84%E8%8C%83/"/>
    <url>/2022/10/29/%E7%A8%8B%E5%BA%8F%E9%A3%8E%E6%A0%BC%E4%B8%8E%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><h2 id="注释">1 注释</h2><h2 id="变量">2 变量</h2><h2 id="接口函数">3 接口（函数）</h2><h2 id="常量">4 常量</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spice仿真</title>
    <link href="/2022/10/29/Spice%E4%BB%BF%E7%9C%9F/"/>
    <url>/2022/10/29/Spice%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理Chapter01</title>
    <link href="/2022/10/04/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86Chapter01/"/>
    <url>/2022/10/04/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86Chapter01/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文主要为数字信号处理课程第一章笔记。</p><span id="more"></span><h2 id="符号表示及基础">1.1 符号表示及基础</h2><p>离散时间信号通常用序列： $ {x(n)}$ ，$ n $ 为 $ 0,1,2 ...$ , $ x(n) $表示为序列中第 $ n $ 个样本值。</p><p>$ {·} $ 表示全部样本值的集合</p><p>$ {x*(n)}$ 表示复序列的共轭</p><p>连续时间序列 $ x{t} $ 与离散时间序列 $ {x(n)}$ 的关系：</p><p><span class="math display">\[x(n) = x_a(t) |_{t = nT} =x_a(nT) \tag {1.1}\]</span> 其中采样频率$ f_s =$（T为采样周期，即两个样本间的时间间隔）</p><p>周期序列表示为 $ (n) $ 其中 <span class="math display">\[\widetilde{x}(n) = x(n+kN) , 0 \leq n \leq N-1 ,k为任意整数 \tag{1.2}\]</span></p><h3 id="常见典型序列">1.1.1 常见典型序列</h3><ol type="1"><li><p>单位脉冲序列 <span class="math display">\[\delta (n)=\left \{\begin{aligned}1, n = 0\\0, n \neq 0 \\\end{aligned}\right. \tag{1.3}\]</span></p></li><li><p>单位阶跃序列 <span class="math display">\[u (n)=\left \{\begin{aligned}1, n \geq 0\\0, n &lt; 0 \\\end{aligned}\right. \tag{1.4}\]</span></p></li><li><p>矩形序列 <span class="math display">\[R_N (n)=\left \{\begin{aligned}1, n \leq n \leq N-1 \\0, n &lt; 0,n \geq N \\\end{aligned}\right. \tag{1.5}\]</span></p></li><li><p>实指数序列 <span class="math display">\[x(n) = a^n u(n) \tag{1.6}\]</span></p></li></ol><p>$ a , |a| &lt; 1 $ 时收敛，<span class="math inline">\(|a| \geq1\)</span> 时发散</p><ol start="5" type="1"><li><p>正弦序列 <span class="math display">\[x(n) = sin(\omega_0n)\tag{1.7}\]</span> <spanclass="math inline">\(\omega_0\)</span>为数字角频率，单位为弧度 <spanclass="math inline">\(rad\)</span></p></li><li><p>复指数序列</p></li></ol><p><span class="math display">\[x(n) = (re^{j\omega_0})^n =r^n[cos(\omega_0n)+jsin(\omega_0n)]\tag{1.8}\]</span></p><h3 id="序列的运算">1.1.2 序列的运算</h3><ol type="1"><li><p>序列的加法 <span class="math display">\[z(n) = x(n) + y(n) \tag{1.9}\]</span></p></li><li><p>序列的相乘 <span class="math display">\[z(n) = x(n)  y(n) \tag{1.10}\]</span></p></li><li><p>序列的位移 <span class="math display">\[z(n) = x(n-n_0) \tag{1.11}\]</span> 当 $ n_0 &gt; 0 $ 时 <span class="math inline">\(z(n)\)</span>是 $ x(n) $ 的延迟；当 $ n_0 &lt; 0 $ 时 <spanclass="math inline">\(z(n)\)</span> 超前于 $ x(n) $ ；</p></li><li><p>序列的能量及序列的绝对值 序列的能量定义为序列样本值的平方和 <spanclass="math display">\[S = \sum^{\infty}_{n = -\infty} |x(n)|^2\tag{1.12}\]</span> 如果序列 <span class="math inline">\(x(n)\)</span> 满足 <spanclass="math inline">\(S &lt; \infty\)</span> 则为平方可和序列如果序列满足 <span class="math display">\[\sum^{\infty}_{n = -\infty} |x(n)| &lt; \infty \tag{1.13}\]</span> 则为绝对可和序列如果序列的每一个样本值的绝对值均小于某一个有限的正整数 <spanclass="math inline">\(B_x\)</span> 则 <spanclass="math inline">\(x(n)\)</span> 为有界序列，即 <spanclass="math display">\[|x(n)| \leq B_x &lt; \infty\tag{1.14}\]</span></p></li><li><p>实序列的偶部和奇部任何序列均可以分解成偶对成序列和奇对称序列的和的形式，即 <spanclass="math display">\[x(n) = x_e(n) + x_o(n)\tag{1.15}\]</span> <span class="math inline">\(x_e(n)\)</span> 和 <spanclass="math inline">\(x_o(n)\)</span> 分别称为 <spanclass="math inline">\(x(n)\)</span> 的偶部和基部，其分别等于 <spanclass="math display">\[x_e(n) = \frac{1}{2}[x(n) + x(-n)]\tag{1.15a}\]</span> <span class="math display">\[x_o(n) = \frac{1}{2}[x(n) - x(-n)]\tag{1.15b}\]</span></p></li><li><p>任意序列的单位脉冲表示 任一序列 <spanclass="math inline">\(x(n)\)</span>都可以表示成单位脉冲序列移位的加权和，即 <span class="math display">\[x(n) = \sum^{\infty}_{m = -\infty}x(m)\delta(n-m)\tag{1.16}\]</span></p></li></ol><h2 id="离散时间信号的傅里叶变换与-z-变换">1.2离散时间信号的傅里叶变换与 $ z $ 变换</h2><h3 id="离散时间信号的傅里叶变换">1.2.1 离散时间信号的傅里叶变换</h3><p>离散时间傅里叶变换 $ DTFT $ (discrete-time Fourier tansform) ,序列的<span class="math inline">\(DTFT\)</span> 定义为： <spanclass="math display">\[X(e^{j\omega}) = \sum^{\infty}_{n = -\infty}x(n)e^{-j\omega n},\omega =\frac{2\pi f}{f_S}\tag{1.17}\]</span> 式中， $ $ 为数字角频率，它是频率 <spanclass="math inline">\(f\)</span> 对采样频率 <spanclass="math inline">\(f_s\)</span> 作归一化后的角频率。 <spanclass="math inline">\(X(e^{j\omega})\)</span> 时 <spanclass="math inline">\(\omega\)</span> 的连续函数，且周期为 <spanclass="math inline">\(2\pi\)</span> 式（<spanclass="math inline">\(1.17\)</span>）级数不一定总是收敛的，当 <spanclass="math inline">\(x(n)\)</span> 绝对可和时，它的 <spanclass="math inline">\(DTFT\)</span> 一定存在。离散时间信号的傅里叶逆变换（<spanclass="math inline">\(IDTFT\)</span>）： <span class="math display">\[x(n) = \frac{1}{2\pi}\int_{-\pi}^{\pi} X(e^{j\omega})e^{j\omega m}d\omega\tag{1.18}\]</span> <span class="math inline">\(x(n)\)</span> 和 <spanclass="math inline">\(X(e^{j\omega})\)</span> 对应关系可表示为：<spanclass="math inline">\(X(e^{j\omega}) = DTFT[x(n)]\)</span> ,<spanclass="math inline">\(x(n)=IDTFT[X(e^{j\omega})]\)</span></p><p><span class="math inline">\(X(e^{j\omega})\)</span> 的几种表示方法：<span class="math display">\[X(e^{j\omega}) = Re[X(e^{j\omega})]+jIm[X(e^{j\omega})] =|X(e^{j\omega})|e^{j\phi(\omega)}\tag{1.19}\]</span> <span class="math inline">\(Re[·]\)</span> 和 <spanclass="math inline">\(Im[·]\)</span> 表示取实部和虚部。 <spanclass="math inline">\(|X(e^{j\omega})|\)</span> 为离散序列 <spanclass="math inline">\(x(n)\)</span> 的幅度谱，<spanclass="math inline">\(\phi(\omega)\)</span>为离散序列的相位谱。</p><p><span class="math inline">\(DTFT\)</span> 的主要特性 |序列|<spanclass="math inline">\(DTFT\)</span>| |:---:|:---:| |<spanclass="math inline">\(ax(n)+by(n)\)</span>|<spanclass="math inline">\(aX(e^{j\omega})+Y(e^{j\omega})\)</span>| |<spanclass="math inline">\(x^*(n)\)</span>|<spanclass="math inline">\(X^*(e^{-j\omega})\)</span>| |<spanclass="math inline">\(x^*(-n)\)</span>|<spanclass="math inline">\(X^*(e^{j\omega})\)</span>| |<spanclass="math inline">\(x(n-n_0)\)</span>|<spanclass="math inline">\(e^{-jn_0\omega}X(e^{j\omega})\)</span>| |<spanclass="math inline">\(e^{j\omega_0 n}x(n)\)</span>|<spanclass="math inline">\(X(e^{j(\omega - \omega_0)})\)</span>| |<spanclass="math inline">\(Re[x(n)]\)</span>|<spanclass="math inline">\(X_e(e^{j\omega})\)</span> [<spanclass="math inline">\(X(e^{j\omega})\)</span> 的共轭偶对称部分]| |<spanclass="math inline">\(jIm[x(n)]\)</span>|<spanclass="math inline">\(X_o(e^{j\omega})\)</span> [<spanclass="math inline">\(X(e^{j\omega})\)</span> 的共轭奇对称部分]| |<spanclass="math inline">\(x(n)\)</span> 为实序列|<spanclass="math inline">\(X(e^{j\omega}) = X^*(e^{-j\omega})\)</span>||<span class="math inline">\(Re[X(e^{j\omega})] =Re[X(e^{-j\omega})]\)</span>| ||<spanclass="math inline">\(Im[X(e^{j\omega})] =-Im[X(e^{-j\omega})]\)</span>| ||<spanclass="math inline">\(arg[X(e^{j\omega})] =-arg[X(e^{-j\omega})]\)</span>| |<spanclass="math inline">\(x_e(n)\)</span> [<spanclass="math inline">\(x(n)\)</span> 的共轭偶对称部分]|<spanclass="math inline">\(Re[X(e^{j\omega})]\)</span>| |<spanclass="math inline">\(x_o(n)\)</span> [<spanclass="math inline">\(x(n)\)</span> 的共轭偶奇称部分]|<spanclass="math inline">\(jIm[X(e^{j\omega})]\)</span>|</p><h3 id="z变换">1.2.2 <span class="math inline">\(z\)</span>变换</h3><p>序列 <span class="math inline">\(x(n)\)</span> 的 <spanclass="math inline">\(z\)</span> 变换定义为： <spanclass="math display">\[X(z) = \sum^{\infty}_{n = -\infty}x(n)z^{-n} ,(n = 0时为单边z变换)\tag{1.20}\]</span> 上式中 <span class="math inline">\(z\)</span>为复变量，也可记为 <span class="math inline">\(\mathscr{Z}[x(n)] =X(z)\)</span> 对于所有的序列或所有的 <spanclass="math inline">\(z\)</span> 值，<spanclass="math inline">\(z\)</span>变换并不总是收敛，使 <spanclass="math inline">\(z\)</span> 变换收敛的 <spanclass="math inline">\(z\)</span> 值的集合称作收敛区域，一般为 <spanclass="math inline">\(z\)</span> 平面上的一个环形区域，该区域为: <spanclass="math display">\[R_{x^-} &lt;|z|&lt;R_{x^+}\tag{1.21}\]</span> 其中 <span class="math inline">\(R_{x^-}\)</span>可以小到0，<span class="math inline">\(R_{x^+}\)</span> 可以大到 <spanclass="math inline">\(\infty\)</span></p><p>以下讨论几种序列的收敛域</p><ol type="1"><li><p>有限长序列 仅有有限个数的序列值是非零值，从而有: <spanclass="math display">\[X(z) = \sum^{n_2}_{n = n_1} x(n) z^{-n}\tag{1.22}\]</span> 其中 <span class="math inline">\(n_1,n_2\)</span>为有限整数，分别为 <span class="math inline">\(x(n)\)</span>的起点和终点。除了当 <span class="math inline">\(n_1 &lt; 0\)</span> 时<span class="math inline">\(z = \infty\)</span> 以及 <spanclass="math inline">\(n_2&gt;0\)</span> 时 <spanclass="math inline">\(z=0\)</span> 之外， <spanclass="math inline">\(z\)</span>所在的区域均收敛，即有限长序列的收敛区域至少是： <spanclass="math display">\[0&lt;|z|&lt;\infty\]</span> 其收敛区域可能包括 <span class="math inline">\(z=0\)</span>或包括 <span class="math inline">\(z=\infty\)</span></p></li><li><p>右边序列 右边序列为 <span class="math inline">\(n&lt;n_1\)</span>时 <span class="math inline">\(x(n)=0\)</span> 的序列， <spanclass="math inline">\(z\)</span> 变换为： <span class="math display">\[X(z) = \sum^{\infty}_{n = n_1} x(n) z^{-n}\tag{1.23}\]</span> 右边序列的收敛域是一个半径为 <spanclass="math inline">\(R_{x^-}\)</span> 的圆的外部，即： <spanclass="math display">\[|Z|&gt;R_{x^-}\]</span> 当 <span class="math inline">\(n_1 \geq 0\)</span> 时 <spanclass="math inline">\(z\)</span> 变换在 <span class="math inline">\(z =\infty\)</span> 处收敛，反之 <span class="math inline">\(n_1 &lt;0\)</span> 时 <span class="math inline">\(z\)</span> 变换在 <spanclass="math inline">\(z = \infty\)</span> 处将不收敛</p></li><li><p>左边序列 左边序列为 <span class="math inline">\(n &gt;n_2\)</span> 时 <span class="math inline">\(x(n)=0\)</span> 的序列，<span class="math inline">\(z\)</span> 变换为： <spanclass="math display">\[X(z) = \sum^{n_2}_{n = -\infty} x(n) z^{-n}\tag{1.24}\]</span> 左边序列的收敛域是一个半径为 <spanclass="math inline">\(R_{x^-}\)</span> 的圆的内部，即： <spanclass="math display">\[|z|&lt;R_{x^+}\]</span> 若<span class="math inline">\(n_2 &lt; 0\)</span> 则左边序列的<span class="math inline">\(z\)</span> 变换在 <spanclass="math inline">\(z = 0\)</span> 处将收敛</p></li><li><p>双边序列 双边序列可视为一个左边序列与一个右边序列之和，其 <spanclass="math inline">\(z\)</span> 变换的收敛域就是这两个序列 <spanclass="math inline">\(z\)</span> 变换的公共收敛区间 <spanclass="math display">\[X(z) = \sum^{\infty}_{n = -\infty}x(n)z^{-n} =\sum^{\infty}_{n = 0} x(n)z^{-n} + \sum^{-1}_{n = -\infty} x(n) z^{-n}\tag{1.25}\]</span> 第一个级数是右边序列，对 <spanclass="math inline">\(|z|&gt;R_{x^-}\)</span>收敛；第二个级数是左边序列，对 <spanclass="math inline">\(|z|&lt;R_{x^+}\)</span> 。 若 <spanclass="math inline">\(R_{x^-} &lt; R_{x^+}\)</span> ，则有一个形式为：<span class="math display">\[R_{x^-} &lt;|z|&lt; R_{x^+}\]</span> 的公共收敛区域。若 <span class="math inline">\(R_{x^-} &gt;R_{x^+}\)</span> ，则没有公共收敛区域，因此式（1.25）不能收敛。</p></li></ol><h3 id="逆z变换">1.2.3 逆<span class="math inline">\(z\)</span>变换</h3><p>已知函数 <span class="math inline">\(X(z)\)</span>及其收敛域，反求序列的变换，其表示及变换关系式（柯西积分定理推导）为：<span class="math display">\[x(n) = \mathscr{Z}^{-1}[X(z)] = \frac{1}{2\pi j} \oint_C X(z)z^{n-1}dz\tag{1.26}\]</span> 式中 <span class="math inline">\(C\)</span> 为 <spanclass="math inline">\(X(z)\)</span>收敛域内的一条逆时针方向绕原点的闭合曲线</p><h3 id="z变换的性质">1.2.4 <spanclass="math inline">\(z\)</span>变换的性质</h3><p><span class="math inline">\(z\)</span>变换特性表 |序列|<spanclass="math inline">\(z\)</span> 变换|收敛域| |:---:|:---:|:---:| |<spanclass="math inline">\(x(n)\)</span>|<spanclass="math inline">\(X(z)\)</span>|$ R_{x^-} &lt;|z|&lt; R_{x^+} <spanclass="math inline">\(| |\)</span>y(n)<spanclass="math inline">\(|\)</span>Y(z)<spanclass="math inline">\(|\)</span> R_{y^-} &lt;|z|&lt; R_{y^+} <spanclass="math inline">\(| |\)</span>ax(n)+bx(n)<spanclass="math inline">\(|\)</span>aX(z)+bY(z)<spanclass="math inline">\(|\)</span>max[R_{x<sup>-},R_{y</sup>-}]&lt;|z|&lt; min[R_{x<sup>+},R_{y</sup>+}]<span class="math inline">\(||\)</span>x(n+n_0)<span class="math inline">\(|\)</span>z^{n_0}X(z)<spanclass="math inline">\(|\)</span> R_{x^-} &lt;|z|&lt; R_{x^+} <spanclass="math inline">\(| |\)</span>a<sup>nx(n)<spanclass="math inline">\(|\)</span>X(a</sup>{-1}z)<spanclass="math inline">\(|\)</span>|a|R_{x^-} &lt;|z|&lt; |a|R_{x^+}<spanclass="math inline">\(| |\)</span>nx(n)<spanclass="math inline">\(|\)</span>-z<span class="math inline">\(|\)</span>R_{x^-} &lt;|z|&lt; R_{x^+} <span class="math inline">\(||\)</span>x<sup><em>(n)<spanclass="math inline">\(|\)</span>X^</em>(z</sup><em>)<spanclass="math inline">\(|\)</span> R_{x^-} &lt;|z|&lt; R_{x^+} <spanclass="math inline">\(| |\)</span>x(-n)<spanclass="math inline">\(|\)</span>X()<spanclass="math inline">\(|\)</span> &lt;|z|&lt; <spanclass="math inline">\(| |\)</span>x(n)</em>y(n)<spanclass="math inline">\(|\)</span>X(z)Y(z)<spanclass="math inline">\(|\)</span>max[R_{x<sup>-},R_{y</sup>-}]&lt;|z|&lt; min[R_{x<sup>+},R_{y</sup>+}]<span class="math inline">\(||\)</span>x(n)y(n)<spanclass="math inline">\(|\)</span><em>CX(v)Y()v<sup>{-1}dv<spanclass="math inline">\(|\)</span>R_{x</sup>-}R</em>{y^-} &lt;|z|&lt;R_{x<sup>+}R_{y</sup>+}<span class="math inline">\(| |\)</span>x(0) =X()<span class="math inline">\(||\)</span>|z|&gt;R_{x^-}<spanclass="math inline">\(| |\)</span>x() = Res[X(z),1]<spanclass="math inline">\(||\)</span>(z-1)X(z)收敛于|z| $|</p><h3 id="z变换与dtft的关系">1.2.5 <spanclass="math inline">\(z\)</span>变换与<spanclass="math inline">\(DTFT\)</span>的关系</h3><p><span class="math display">\[X(z)|_{z = e^{j\omega}} =\sum^{\infty}_{n=-\infty}x(n)e^{-jn\omega}\tag{1.27}\]</span> 当 <span class="math inline">\(z = e^{j\omega}\)</span>时，<span class="math inline">\(z\)</span> 变换与 <spanclass="math inline">\(DTFT\)</span> 相等，即采样序列单位圆上的<spanclass="math inline">\(z\)</span>变换就等于该序列的<spanclass="math inline">\(DTFT\)</span> 由于<spanclass="math inline">\(e^{j\omega} = e^{j(\omega + 2k\pi)}\)</span> ,所以<span class="math inline">\(X(e^{j\omega})\)</span> 是以 <spanclass="math inline">\(2\pi\)</span> 为周期的周期函数， <spanclass="math inline">\(z\)</span> 平面单位圆上一周正好对应 <spanclass="math inline">\(X(e^{j\omega})\)</span> 的一个周期。</p><h3 id="parseval-定理">1.2.6 Parseval 定理</h3><p>设两个序列 <span class="math inline">\(x(n),y(n)\)</span>则Paseval定理为： <span class="math display">\[\sum^{\infty}_{n=-\infty}x(n)y^*(n)=\frac{1}{2\pij}\oint_CX(v)Y^*(\frac{1}{v^*})v^{-1}dv\tag{1.28}\]</span></p><p>上式中，积分围线取在 <span class="math inline">\(X(v)\)</span> 和<span class="math inline">\(Y^*(\frac{1}{v^*})\)</span>的收敛区域的交叠范围内。Parseval定理的一个很重要的应用式计算序列的能量：</p><p><span class="math display">\[\sum^{\infty}_{n=-\infty}|x(n)|^2 =\sum^{\infty}_{n=-\infty}x(n)x^*(n)=\frac{1}{2\pi}\int^\pi_{-\pi}X(e^{j\omega})X^*(e^{j\omega})d\omega= \frac{1}{2\pi}\int^\pi_{-\pi}|X(e^{j\omega})|^2d\omega\tag{1.29}\]</span></p><h2 id="离散时间系统">1.3 离散时间系统</h2><p>离散时间系统在数学上定义为将输入序列 <spanclass="math inline">\(x(n)\)</span> 映射成输出序列 <spanclass="math inline">\(y(n)\)</span>的唯一性变换或运算，或者说将一个序列变换成另一个序列的系统。表示为：<span class="math display">\[y(n) = T[x(n)]\tag{1.30}\]</span></p><pre><code class=" mermaid">graph LR;    A[&quot;输入序列x(n)&quot;] --&gt; B[&quot;运算T[·]&quot;];    B --&gt; C[&quot;输出序列y(n)&quot;];</code></pre><p>算子 <span class="math inline">\(T[·]\)</span> 表示种种约束条件。</p><h3 id="线性系统linear-system">1.3.1 线性系统（Linear system）</h3><p>满足叠加原理的系统具有线性特性。即若对两个激励 <spanclass="math inline">\(x_1(n)\)</span> 和 <spanclass="math inline">\(x_2(n)\)</span> 有： <span class="math display">\[T[ax_1(n)+bx_2(n)] = aT[x_1(n)]+bT[x_2(n)],a,b为任意常数\tag{1.31}\]</span> 线性系统满足叠加性原理，不满足上述关系的为非线性系统。</p><pre><code class=" mermaid">graph LR    A[&quot;x1(n)&quot;] --&gt; B[&quot;T[·]&quot;]    B --&gt; C[&quot;y1(n)&quot;]    X[&quot;x2(n)&quot;] --&gt; Y[&quot;T[·]&quot;]    Y --&gt; Z[&quot;y2(n)&quot;]    M[&quot;ax1(n)+bx2(n)&quot;] --&gt; L[&quot;T[·]&quot;]    L --&gt; N[&quot;ay1(n)+by2(n)&quot;]</code></pre><h3 id="时不变time-invariant系统">1.3.2时不变（time-invariant）系统</h3><p>时不变系统就是系统的参数不随时间而变化，不管输入信号作用的时间先后，输出信号响应的形状均相同，仅出现的时间不同。<span class="math display">\[T[x(n)] = y(n)T[x(n-n_0)] = y(n - n_0)\tag{1.32}\]</span></p><pre><code class=" mermaid">graph LR    A[&quot;x(n)&quot;] --&gt; B[&quot;T[·]&quot;]    B --&gt; C[&quot;y(n)&quot;]    X[&quot;x(n-n0)&quot;] --&gt; Y[&quot;T[·]&quot;]    Y --&gt; Z[&quot;y(n-n0)&quot;]</code></pre><h3 id="线性时不变linear-time-invariant-lti系统">1.3.3线性时不变（linear time-invariant, LTI）系统</h3><h3 id="稳定系统stable-system和因果系统causal-system">1.3.4稳定系统（stable system）和因果系统（causal system）</h3><p>只要输入序列是有界的，其输出必定是有界的，这样的系统称为稳定系统，稳定系统的充要条件是其单位脉冲响应绝对可和，即：<span class="math display">\[\sum^{\infty}_{n=-\infty}|h(n)|&lt;\infty\]</span></p><p>因果系统，就是系统的输出只取决于此时以及此时以前的输入（ <spanclass="math inline">\(x(n),x(n-1),x(n-2)...\)</span> 等）一个线性时不变系统是因果系统的充要条件是 <span class="math display">\[h(n) \equiv 0,n&lt;0\]</span> 通常将 <span class="math inline">\(n&lt;0\)</span> 时等于<span class="math inline">\(0\)</span> 的序列称为因果序列。</p>]]></content>
    
    
    <categories>
      
      <category>Learn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Review</tag>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言程序中变量的作用域问题</title>
    <link href="/2022/07/14/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/14/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8EC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>在使用C语言编写程序时，根据不同程序的要求，有时对于程序内部的数据传递，数据处理，数据使用等问题上会有很多要求。例如，在程序模块化设计时，各个模块尽量需要可以封装起来，方便使用，同时函数内部的数据会有两种不同的需求。<span id="more"></span></p><p>第一种则是尽量希望模块内部的数据不被访问，只传递输出结果即可，或者是希望每次函数被调用后，能够释放掉内部使用的内存空间。第二种情况就是函数内部的数据不被释放，能够在调用后存留下来，在循环或者重复调用时其中的数据能给予上次调用的基础上继续更改，甚至希望可以调用其内部的数据。对于上述的两个问题或者说是要求，就需要了解C语言程序中变量的作用域的问题。本文将通过诸多例程来厘清这其中的关系。</p>]]></content>
    
    
    <categories>
      
      <category>C&#92;C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>增量式PID介绍（Python语言实现）</title>
    <link href="/2022/07/08/%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E4%BB%8B%E7%BB%8D%E5%8F%8APython%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/07/08/%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E4%BB%8B%E7%BB%8D%E5%8F%8APython%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>本文主要记录在电子设计大赛训练时，做电源时需要对电路中某些输出量进行稳定控制，PID控制算法可以很好的实现该功能，其中增量式更符合对电源的电压电流量的控制。本文主要粗略对其进行介绍再使用Python实现一个电压输出稳定控制<span id="more"></span> ## 1.增量式PID算法介绍</p><p>以下仅限与对增量式PID控制算法的介绍，对于PID控制算法的概述（GeneralIntroduction）见“PID控制器入门概要”</p><p>增量式PID控制将当前时刻的控制量和上一时刻的控制量做差，以差值为新的控制量，是一种递推式的算法。</p><p>其公式表示为： <span class="math display">\[\Delta u(k) = K_p (e(k) - e(k-1)) + K_i e(k) + K_d(e(k) - 2e(k-1) +e(k-2)) \tag{1}\]</span> 其中:</p><ul><li><span class="math inline">\(K_p\)</span>为比例系数</li><li><span class="math inline">\(K_i\)</span>为积分系数</li><li><span class="math inline">\(K_d\)</span>为微分系数</li></ul><p>因此若要使用增量式PID算法需要保存<spanclass="math inline">\(e(k-1),e(k-2)\)</span>两个时刻的输出值，在加上输出回馈值<spanclass="math inline">\(e(k)\)</span>的积分注意：增量式PID的运算结果为<spanclass="math inline">\(u(k)\)</span>同<spanclass="math inline">\(u(k-1)\)</span>之间的差值，因此输出结果需叠加，即为：<span class="math display">\[u(k) = u(k-1) + \Delta(k)\]</span> <img src="/image/pidzengliang/zengliangpid.png"alt="增量PID流程框图" /> 厘清<spanclass="math inline">\(u(k),u(k-1),\Deltau,e(k),e(k-1),e(k-2)\)</span></p><h2 id="使用python语言进行实现">2.使用Python语言进行实现</h2><p>下面使用Python语言进行展示，得到输出曲线假设如下案例，现有一DCDC升压（BOOST）电路，需要将15V的初始电压提升到30V，控制方式为驱动MOS管周期内导通与关断时间比值即可。但现在只关注电压输入与控制后输出的结果，不考虑PWM占空比，定时器计数等问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 名称：PID算法（增量式）</span><br><span class="hljs-comment"># 作者：Shixin</span><br><span class="hljs-comment"># 更新时间：2022.07.08 21.55</span><br><span class="hljs-comment"># 版本: 1.0</span><br><span class="hljs-keyword">import</span> numpy<br><span class="hljs-keyword">import</span> pandas<br><span class="hljs-keyword">import</span> matplotlib.pyplot<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    Setpoint = <span class="hljs-number">30.0</span><br>    out = <span class="hljs-number">0.0</span><br>    k_p = <span class="hljs-number">0.05</span><br>    k_i = <span class="hljs-number">0.2</span><br>    k_d = <span class="hljs-number">0.1</span><br>    e_k1 = <span class="hljs-number">0.0</span><br>    e_k2 = <span class="hljs-number">0.0</span><br>    time = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>)<br>    output = numpy.arange(<span class="hljs-number">1.0</span>, <span class="hljs-number">51.0</span>, <span class="hljs-number">1.0</span>)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> time:<br>        e_k = Setpoint - out<br>        outk = k_p * (e_k - e_k1) + k_i * e_k + k_d * (e_k - <span class="hljs-number">2</span> * e_k1 + e_k2)<br>        e_k2 = e_k1<br>        e_k1 = e_k<br>        out = out + outk<br>        <span class="hljs-built_in">print</span>(out)<br>        output[i] = out<br><br>    matplotlib.pyplot.plot(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">51</span>, <span class="hljs-number">1</span>), output)<br>    matplotlib.pyplot.show()<br><br>    <span class="hljs-built_in">print</span>(output)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><p>通过不断改变<spanclass="math inline">\(K_p,K_i,K_d\)</span>三个值最终可以得到一个十分合适的输出曲线：<img src="/image/pidzengliang/pidout.png" alt="PID输出曲线" />观察该曲线可以发现系统可以很达到了稳定状态，且到达稳定点的时间也很快观察如下数值结果： <img src="/image/pidzengliang/pidshuzhijieguo.png"alt="PID输出数值结果" />可以看到在数值上达到预期值的效果也十分理想，误差小于0.001</p><h2 id="其他的一些问题">3.其他的一些问题</h2><p>当我在做DC-DC电源转换器直流稳压源时，发现由于系统反应过于迅速以至于转换器来不及反应导致系统无法达到预期目的，因此需要将参数调小并留有一定的系统反应时间。</p><h2 id="近一年后">4.近一年后</h2><p>在使用过程中我又对上述的PID计算代码进行了进一步封装，使用的时候可以向PID计算过程直接传递Kp, Ki, Kd参数，使用起来更为方便，且封装后的代码可以针对不同的过程使用，不必考虑其他问题，诸如：</p><ul><li>变量的存储空间是否会相互影响</li><li>是否要考虑计算的内容是否为有特定单位的有意义的物理量</li><li>计算时的变量是否可见可读</li></ul><p>代码封装之后，所有的PID计算全部进行了归一化，输出结果的范围为 <spanclass="math inline">\([-1,1]\)</span>,使用时需要自行缩放到需要的有物理意义的结果。这样作的好处之一就是，Matlab仿真的结构可以直接使用这个代码进行处理（Simulink仿真的PID计算输出均为归一化的结果）。</p><p>封装后的函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/**   </span><br><span class="hljs-comment">  * @brief  PID Calculator, You can define different Parameter when use it.   </span><br><span class="hljs-comment">  * @param  Now_out: Sensor Data OR Output right now that you want   </span><br><span class="hljs-comment">  *                  to INPUT the PID calculation.   </span><br><span class="hljs-comment">  * @param  Target: Your wanted Target   </span><br><span class="hljs-comment">  * @param  Parameter:  The Kp, Ki, Kd Parameter that you want use.   </span><br><span class="hljs-comment">  * @param  UpperLimit: Limit the upper side of the PID calculation final output   </span><br><span class="hljs-comment">  * @param  LowerLimit: Limit the lower side of the PID calculation final output   </span><br><span class="hljs-comment">  * @retval None   </span><br><span class="hljs-comment">  */</span><br><br><span class="hljs-type">float</span> <span class="hljs-title function_">pidCalc</span><br> <span class="hljs-params">(<span class="hljs-type">float</span> Now_out, <span class="hljs-type">float</span> Target, <span class="hljs-keyword">struct</span> strPID Parameter ,<span class="hljs-type">float</span> UpperLimit ,<span class="hljs-type">float</span> LowerLimit)</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C&#92;C++</category>
      
      <category>Control</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Control</tag>
      
      <tag>Python</tag>
      
      <tag>PID</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
